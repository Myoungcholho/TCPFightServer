# 📌프로젝트 개요
<p align="center">
  <img
    width="800"
    src="https://github.com/user-attachments/assets/fa86d4bc-949f-45dd-81ea-27795a1911d1"
    alt="Server" />
</p>

간단한 설명 추가

| 항목 | 내용 |
|------|------|
| 🕒 개발 기간 | 2023.02 ~ 2023.03 (40일) |
| 👤 개발 인원 | 1명 |
| 🧰 개발 환경 | C |
| 🛠 실행 및 디버깅 툴 | VS2022, WireShark |
| 📦 라이브러리 | Socket |

</br>

# 📘목차
- [구현 내용](#구현-내용)
- [핵심 주요 코드](#핵심-주요-코드)
- [개발 계기](#개발-계기)
- [아쉬웠던 점](#아쉬웠던-점)
- [프로젝트에서 얻은 것](#프로젝트에서-얻은-것)
- [문제 해결 경험(트러블 슈팅)](#문제-해결-경험트러블-슈팅)

</br>

# 📘구현 내용

| 구현 내용 | 설명 |
|-----------|------|
| TCP 통신용 경량 패킷 모듈 | 고정 버퍼 기반 `<< / >>` 연산자 직렬화·역직렬화 처리 |
| 패킷 처리용 링버퍼 자료구조 | 입력 버퍼 순환 처리 및 안정적인 스트림 관리 |
| 패킷 헤더 파싱 & 브로드캐스트 | 이동·공격·데미지 처리 및 다수 클라이언트 동기화 |
| 비정상 입력 유효성 검증 로직 | 좌표 연타 등 비정상 패킷 필터링 및 보안 처리 |

</br>

# 📘핵심 주요 코드
- [링 버퍼 컨테이너](https://github.com/Myoungcholho/TCPFightServer/blob/master/TCPserializationFightProject/RingBuffer.cpp)
- [패킷 직렬화 클래스](https://github.com/Myoungcholho/TCPFightServer/blob/master/TCPserializationFightProject/CPacket.h)
- [서버 로직](https://github.com/Myoungcholho/TCPFightServer/blob/master/TCPserializationFightProject/main.cpp)

| 코드 파일 | 코드 설명 |
|----------|-----------|     
| UAnimInstance [.h]() / [.cpp]() | 애니메이션 클립의 재생 시간과 상태를 관리하고, 블렌딩을 처리해 본 팔레트에 쓸 로컬 포즈를 만들어주는 실행기입니다. |

</br>

# 📘개발 계기

온라인 멀티플레이의 구조가 어떻게 동작하는지에 대한 궁금증과,  
이론으로만 배우는 네트워크가 아니라, 실제로 클라이언트–서버 구조를  
직접 구현하며 데이터가 오가는 흐름을 체감해 보고 싶어 본 프로젝트를 시작했습니다.

# 📘아쉬웠던 점

**요약**
- [1. 패킷 전송 최적화 부족](#weak-arch)
- [2. 절차지향으로 인한 확장성 부족](#weak-optim)

---

### 1. 패킷 전송 최적화 부족 <a id="weak-arch"></a>

처음에는 플레이어의 이동 좌표를 매 프레임 송신하도록 구현했지만,  
이는 헤더 낭비로 이어졌습니다.  

이후 상태 변화 시에만 패킷을 송신하는 방식으로 변경하여 트래픽을 크게 줄였습니다.

---

### 2. 절차지향으로 인한 확장성 부족 <a id="weak-optim"></a>

네트워크 로직에만 집중하다 보니 객체화·모듈화를 거의 하지 못해,  
한 파일에 1000줄이 넘는 절차지향 코드로 구현하게 되었습니다.

필요한 기능을 떠오르는 순서대로 함수만 추가하다 보니,  
재사용성과 확장성 면에서 한계가 분명했고,  
전역적으로 늘어진 함수들로 인해 코드 읽기도 불편했습니다.

다만 이 경험 덕분에 “어디까지가 한 객체의 책임인지”를 몸으로 느낄 수 있었고,  
이후 프로젝트에서는 초기 설계 단계부터 객체지향 구조를 더 신경 쓰게 되는 계기가 되었습니다.

# 📘프로젝트에서 얻은 것

**요약**
- [1. TCP 송·수신 예외 처리 경험](#project01)
- [2. 공격 패킷 연타 등 비정상 입력 검증 로직 구현 경험](#project02)
- [3. 삭제 객체의 안전한 관리 전략](#project03)
- [4. 링버퍼 기반 패킷 처리 구조 설계 경험](#project04)

---

### 1. TCP 송·수신 예외 처리 경험 <a id="project01"></a>

논블로킹 소켓을 사용하며 WSAEWOULDBLOCK 예외가 빈번하게 발생했고,  
이를 처리하는 과정에서 송·수신 상태 기반의 처리 흐름 제어,  
예외 발생 시 재시도 정책 설계의 중요성을 체감했습니다.

---

### 2. 공격 패킷 연타 등 비정상 입력 검증 로직 구현 경험 <a id="project02"></a>

공격 패킷을 반복으로 보내거나 좌표값을 비정상적으로 변조하는 상황을 고려해  
서버 단에서 좌표 검증 및 Cool-Time 관리 로직을 추가했습니다.  
이를 통해 P2P 구조 게임에서 보안과 검증 단의 중요성을 느꼈습니다.

---

### 3. 삭제 객체의 안전한 관리 전략 <a id="project03"></a>

접속 종료된 플레이어를 즉시 삭제하지 않고 Out 큐에 모아  
프레임 말에 일괄 처리하도록 설계해, 삭제 시점에 발생할 수 있는  
데이터 접근 충돌을 막고 안정적인 메모리 흐름을 확보했습니다.

이 경험은 이후 DX 프로젝트에서 액터 수명 관리를 위한 컨테이너 설계의 기초가 되었고,  
언리얼 엔진의 객체 삭제 라이프사이클을 이해하는 데에도 기반이 되었습니다.

---

### 4. 링버퍼 기반 패킷 처리 구조 설계 경험 <a id="project04"></a>

송·수신 버퍼를 링버퍼로 구성해 패킷 단위 일괄 처리,  
직렬화·역직렬화 효율성 개선을 구현했습니다.

링버퍼 컨테이너를 구현하기 위해 1일간 프로그램의 안정성을 검증한 결과는  
프로그래머로써의 안전 문제를 직시하게됐습니다.

# 📘문제 해결 경험(트러블 슈팅)

**요약**
- [1. 이동 좌표 지속 송신으로 인한 트래픽 증가 문제](#tag01)
- [2. 비정상 공격 패킷 반복 전송 문제](#tag02)
- [3. 삭제된 객체 접근으로 인한 크래시 문제 ](#tag03)

### 1. 이동 좌표 지속 송신으로 인한 트래픽 증가 문제 <a id="tag01"></a>

- 문제 상황 & 원인 분석

플레이어 좌표를 이동 중일 때마다 매 프레임 송신하도록 구현해  
불필요한 트래픽이 발생하고, 패킷 헤더에 드는 비용이 과도하게 증가했습니다.

- 해결

좌표 변화나 공격 발생과 같은 이벤트 기반 송신 방식으로 전환했습니다.

모든 프레임에서 패킷을 보내는 대신, 중요한 시점에서만 송신하고  
서버가 이를 검증하도록 구조를 변경했습니다.

- 결과
  
송·수신되는 패킷 수가 눈에 띄게 줄어들었고,  
전체 트래픽이 확연히 감소하는 것을 확인할 수 있었습니다.

- 배운 점  

네트워크 설계에서 전송량 최소화 전략이 핵심이며,  
불필요한 데이터 전송은 처음 구조를 설계하는 단계부터 고려해야 한다는 것을 배웠습니다.

또한, 지금은 소규모 환경이지만 만약 동시 접속자가 1,000명, 10,000명 수준으로 늘어난다면  
패킷 수와 처리해야 할 데이터가 기하급수적으로 증가하고,  
라우터 등 하드웨어에도 큰 부담이 될 것이라는 점을 체감할 수 있었습니다.

---

### 2. 비정상 공격 패킷 반복 전송 문제 <a id="tag02"></a>

- 문제 상황  

클라이언트가 쿨타임을 무시하기 위해 공격 패킷을 반복적으로 전송할 수 있는 상황이었고,  
서버에는 이를 검증하는 보호 로직이 없는 상태였습니다.

- 해결  

서버에서 각 플레이어의 공격 쿨타임을 별도로 기록하고,  
다음에 들어온 공격 패킷과 비교해 현재 시점에 공격이 유효한지를 확인하도록 수정했습니다.

- 결과  

쿨타임 무시 공격과 같은 치트 행위를 차단할 수 있었고,  
비정상 패킷으로 인한 서버 동작의 안정성을 높일 수 있었습니다.

- 배운 점  

클라이언트는 항상 의도대로만 동작한다고 가정할 수 없으며,  
서버는 클라이언트 입력을 절대 전적으로 신뢰해서는 안 된다는 원칙의 중요성을 체감했습니다.

클라이언트에도 방어 코드가 들어가겠지만,  
어떤 형태의 패킷이 서버로 들어올지는 알 수 없기 때문에  
서버 레벨에서도 방어·검증 로직을 촘촘히 설계하는 것이 필수적임을 깨달았습니다.

---

### 3. 삭제된 객체 접근으로 인한 크래시 문제 <a id="tag03"></a>

- 문제 상황 & 원인

접속이 종료된 플레이어를 즉시 삭제하면서,  
아직 해당 객체를 참조 중인 로직과 접근 순서가 꼬여 크래시가 발생하는 문제가 있었습니다.

- 해결  

삭제가 필요한 객체를 바로 지우지 않고 OutQueue에 모아두었다가  
프레임 끝에서 일괄 삭제하도록 변경했습니다.

이로써 로직이 실행 중인 동안에는 안전하게 접근이 보장되고,  
삭제 시점도 명확히 관리할 수 있게 되었습니다.

- 배운 점

삭제된 객체 접근으로 크래시가 발생한 경험을 통해,  
객체 수명 관리와 삭제 시점 설계의 중요성을 깊이 체감했습니다.

단순히 지연 삭제 개념을 알고 있는 것과, 직접 문제를 겪고 해결하는 경험은 큰 차이가 있었고,  
이후 프로젝트에서는 안정성과 참조 안전성에 훨씬 더 민감하게 접근하게 되었습니다.

또한 이 경험은 이후 언리얼 엔진의 객체 라이프사이클과 GC 방식에 대한 관심으로 이어져  
더 견고한 구조 설계의 중요성을 이해하는 계기가 되었습니다.

