# 📘서버 개발 프로젝트
<br>
<img align="right" width="420"
     src="https://github.com/user-attachments/assets/dfd750c5-077d-4277-a8be-56e96834d667"
     alt="Server" />

- 개발 기간: 2023.02.24 ~ 2023.03.06 (10일)
- 개발 인원: 1인
- 핵심 요약: TCP 기반 통신 구조를 이해하고, 패킷 직렬화·역직렬화 모듈과  
  링버퍼 기반 패킷 처리 구조를 구현한 서버 사이드 프로젝트입니다.
- 개발 환경: Socket, C, VS2022, WireShark

<br clear="both"/>

# 📘목차
- [개발 계기](#개발-계기)
- [아쉬웠던 점](#아쉬웠던-점)
- [프로젝트에서 얻은 것](#프로젝트에서-얻은-것)
- [구현 내용](#구현-내용)
- [문제 해결 경험(트러블 슈팅)](#문제-해결-경험트러블-슈팅)
- [핵심 주요 코드](#핵심-주요-코드)

# 📘개발 계기

네트워크 통신 구조를 직접 구현해보고,  
클라이언트와 서버 간 데이터 동기화 방식의 본질을  
이해하고 싶어서 시작하게 되었습니다.

# 📘아쉬웠던 점

**요약**
- [1. 패킷 전송 최적화 부족](#weak-arch)
- [2. 절차지향으로 인한 확장성 부족](#weak-optim)

---

### 1. 패킷 전송 최적화 부족 <a id="weak-arch"></a>

처음에는 플레이어의 이동 좌표를 매 프레임 송신하도록 구현했지만,  
이는 헤더 낭비로 이어졌습니다.  

이후 상태 변화 시에만 패킷을 송신하는 방식으로 변경하여 트래픽을 크게 줄였습니다.

---

### 2. 절차지향으로 인한 확장성 부족 <a id="weak-optim"></a>

네트워크 로직에만 집중하다 보니 객체화·모듈화를 거의 하지 못해,  
한 파일에 1000줄이 넘는 절차지향 코드로 구현하게 되었습니다.

필요한 기능을 떠오르는 순서대로 함수만 추가하다 보니,  
재사용성과 확장성 면에서 한계가 분명했고,  
전역적으로 늘어진 함수들로 인해 코드 읽기도 불편했습니다.

다만 이 경험 덕분에 “어디까지가 한 객체의 책임인지”를 몸으로 느낄 수 있었고,  
이후 프로젝트에서는 초기 설계 단계부터 객체지향 구조를 더 신경 쓰게 되는 계기가 되었습니다.

# 📘프로젝트에서 얻은 것

**요약**
- [1. TCP 송·수신 예외 처리 경험](#project01)
- [2. 공격 패킷 연타 등 비정상 입력 검증 로직 구현 경험](#project02)
- [3. 삭제 객체의 안전한 관리 전략](#project03)
- [4. 링버퍼 기반 패킷 처리 구조 설계 경험](#project04)

---

### 1. TCP 송·수신 예외 처리 경험 <a id="project01"></a>

논블로킹 소켓을 사용하며 WSAEWOULDBLOCK 예외가 빈번하게 발생했고,  
이를 처리하는 과정에서 송·수신 상태 기반의 처리 흐름 제어,  
예외 발생 시 재시도 정책 설계의 중요성을 체감했습니다.

---

### 2. 공격 패킷 연타 등 비정상 입력 검증 로직 구현 경험 <a id="project02"></a>

공격 패킷을 반복으로 보내거나 좌표값을 비정상적으로 변조하는 상황을 고려해  
서버 단에서 좌표 검증 및 Cool-Time 관리 로직을 추가했습니다.  
이를 통해 P2P 구조 게임에서 보안과 검증 단의 중요성을 느꼈습니다.

---

### 3. 삭제 객체의 안전한 관리 전략 <a id="project03"></a>

접속 종료된 플레이어를 즉시 삭제하지 않고 Out 큐에 모아  
프레임 말에 일괄 처리하도록 설계해, 삭제 시점에 발생할 수 있는  
데이터 접근 충돌을 막고 안정적인 메모리 흐름을 확보했습니다.

이 경험은 이후 DX 프로젝트에서 액터 수명 관리를 위한 컨테이너 설계의 기초가 되었고,  
언리얼 엔진의 객체 삭제 라이프사이클을 이해하는 데에도 기반이 되었습니다.

---

### 4. 링버퍼 기반 패킷 처리 구조 설계 경험 <a id="project04"></a>

송·수신 버퍼를 링버퍼로 구성해 패킷 단위 일괄 처리,  
직렬화·역직렬화 효율성 개선을 구현했습니다.

링버퍼 컨테이너를 구현하기 위해 1일간 프로그램의 안정성을 검증한 결과는  
프로그래머로써의 안전 문제를 직시하게됐습니다.


# 📘구현 내용

- TCP 통신용 경량 패킷 모듈 구현 (고정 버퍼 기반 << / >> 연산자 직렬화·역직렬화)
- 패킷 처리를 위한 링버퍼 자료구조 구현
- 패킷 헤더 파싱, 이동·공격·데미지 처리 및 브로드캐스트 기능
- 좌표 연타 등 비정상 입력 유효성 검증 로직 구현


# 📘문제 해결 경험(트러블 슈팅)

**요약**
- [1. 이동 좌표 지속 송신으로 인한 트래픽 증가 문제](#tag01)
- [2. 비정상 공격 패킷 반복 전송 문제](#tag02)
- [3. 삭제된 객체 접근으로 인한 크래시 문제 ](#tag03)

### 1. 이동 좌표 지속 송신으로 인한 트래픽 증가 문제 <a id="tag01"></a>

- 문제 상황  

플레이어의 좌표가 이동 중일 때 매 프레임 송신하여 불필요한 트래픽이 발생하고 헤더 비용이 크게 증가함.

- 원인 분석  

변화가 없을 때도 불필요한 패킷 송신이 반복되어 대역폭 비효율, 서버 처리량 증가 문제 발생.

- 해결

좌표 변화, 공격 등 이벤트 기반 송신 방식으로 전환.

- 결과

트래픽 감소 & 서버 처리 안정성 향상.  

- 배운 점  

네트워크는 전송량 최소화 전략이 핵심이며,
불필요한 데이터 전송 방지는 구조 설계 단계부터 고려해야 함.

---

### 2. 비정상 공격 패킷 반복 전송 문제 <a id="tag02"></a>

- 문제 상황  

클라이언트가 Cool-Time 무시를 위해 공격 패킷을 반복적으로 전송.

- 원인 분석  

서버에 검증 로직 부재.

- 해결  

서버 측에서 공격 쿨타임 및 패킷 정상 범위 검증.

- 결과  

치트 행위 차단, 서버 안정성 향상.

- 배운 점  

서버는 항상 Client 입력을 신뢰하지 않는다는 원칙의 중요성.

---

### 3. 삭제된 객체 접근으로 인한 크래시 문제 <a id="tag03"></a>

- 문제 상황 & 원인

접속 종료된 플레이어가 바로 삭제돼 접근 순서 충돌 및 크래시 발생 가능.

- 해결  

삭제 예정 객체를 OutQueue에 임시 저장하여 프레임 말에 일괄 처리.

- 배운 점


# 📘핵심 주요 코드
- 
